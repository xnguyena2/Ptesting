package com.example.heroku.model.repository;

import com.example.heroku.model.ProductImport;
import com.example.heroku.model.joinwith.GroupImportJoinProductImport;
import org.springframework.data.r2dbc.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import reactor.core.publisher.Flux;

import java.time.LocalDateTime;


public interface JoinGroupImportWithProductImportRepository extends ReactiveCrudRepository<GroupImportJoinProductImport, Long> {
    @Query(value = "SELECT group_import.*, product_import.id AS child_id, product_import.group_id AS child_group_id, product_import.createat AS child_createat, product_import.group_import_second_id AS child_group_import_second_id, product_import.product_second_id AS child_product_second_id, product_import.product_unit_second_id AS child_product_unit_second_id, product_import.product_unit_name_category AS child_product_unit_name_category, product_import.price AS child_price, product_import.amount AS child_amount, product_import.note AS child_note, product_import.list_product_serial_id AS child_list_product_serial_id, product_import.type AS child_type, product_import.status AS child_status FROM (SELECT * FROM group_import WHERE group_import.group_id = :group_id AND group_import.status IS DISTINCT FROM :not_status AND group_import.type = :type ORDER BY createat DESC LIMIT :size OFFSET (:page * :size)) AS group_import LEFT JOIN (SELECT * FROM product_import WHERE product_import.group_id = :group_id) AS product_import ON group_import.group_import_second_id = product_import.group_import_second_id")
    Flux<GroupImportJoinProductImport> getGroupIfNotStatusAndType(@Param("group_id") String groupID, @Param("not_status") ProductImport.Status not_status, @Param("type") ProductImport.ImportType type, @Param("page") int page, @Param("size") int size);

    @Query(value = "SELECT group_import.*, product_import.id AS child_id, product_import.group_id AS child_group_id, product_import.createat AS child_createat, product_import.group_import_second_id AS child_group_import_second_id, product_import.product_second_id AS child_product_second_id, product_import.product_unit_second_id AS child_product_unit_second_id, product_import.product_unit_name_category AS child_product_unit_name_category, product_import.price AS child_price, product_import.amount AS child_amount, product_import.note AS child_note, product_import.list_product_serial_id AS child_list_product_serial_id, product_import.type AS child_type, product_import.status AS child_status FROM (SELECT * FROM group_import WHERE group_import.group_id = :group_id AND group_import.status IS DISTINCT FROM :not_status ORDER BY createat DESC LIMIT :size OFFSET (:page * :size)) AS group_import LEFT JOIN (SELECT * FROM product_import WHERE product_import.group_id = :group_id) AS product_import ON group_import.group_import_second_id = product_import.group_import_second_id")
    Flux<GroupImportJoinProductImport> getGroupIfNotStatus(@Param("group_id") String groupID, @Param("not_status") ProductImport.Status not_status, @Param("page") int page, @Param("size") int size);

    @Query(value = "SELECT group_import.*, product_import.id AS child_id, product_import.group_id AS child_group_id, product_import.createat AS child_createat, product_import.group_import_second_id AS child_group_import_second_id, product_import.product_second_id AS child_product_second_id, product_import.product_unit_second_id AS child_product_unit_second_id, product_import.product_unit_name_category AS child_product_unit_name_category, product_import.price AS child_price, product_import.amount AS child_amount, product_import.note AS child_note, product_import.list_product_serial_id AS child_list_product_serial_id, product_import.type AS child_type, product_import.status AS child_status FROM (SELECT * FROM group_import WHERE group_import.group_id = :group_id AND group_import.status IS DISTINCT FROM :not_status AND group_import.type = :type AND (group_import.createat AT TIME ZONE '+07' BETWEEN :fromtime AND :totime) ORDER BY createat DESC LIMIT :size OFFSET (:page * :size)) AS group_import LEFT JOIN (SELECT * FROM product_import WHERE product_import.group_id = :group_id) AS product_import ON group_import.group_import_second_id = product_import.group_import_second_id")
    Flux<GroupImportJoinProductImport> getGroupIfNotStatusBetweenAndType(@Param("group_id") String groupID, @Param("fromtime") LocalDateTime from, @Param("totime") LocalDateTime to, @Param("not_status") ProductImport.Status not_status, @Param("type") ProductImport.ImportType type, @Param("page") int page, @Param("size") int size);

    @Query(value = "SELECT group_import.*, product_import.id AS child_id, product_import.group_id AS child_group_id, product_import.createat AS child_createat, product_import.group_import_second_id AS child_group_import_second_id, product_import.product_second_id AS child_product_second_id, product_import.product_unit_second_id AS child_product_unit_second_id, product_import.product_unit_name_category AS child_product_unit_name_category, product_import.price AS child_price, product_import.amount AS child_amount, product_import.note AS child_note, product_import.list_product_serial_id AS child_list_product_serial_id, product_import.type AS child_type, product_import.status AS child_status FROM (SELECT * FROM group_import WHERE group_import.group_id = :group_id AND group_import.status IS DISTINCT FROM :not_status AND (group_import.createat AT TIME ZONE '+07' BETWEEN :fromtime AND :totime) ORDER BY createat DESC LIMIT :size OFFSET (:page * :size)) AS group_import LEFT JOIN (SELECT * FROM product_import WHERE product_import.group_id = :group_id) AS product_import ON group_import.group_import_second_id = product_import.group_import_second_id")
    Flux<GroupImportJoinProductImport> getGroupIfNotStatusBetween(@Param("group_id") String groupID, @Param("fromtime") LocalDateTime from, @Param("totime") LocalDateTime to, @Param("not_status") ProductImport.Status not_status, @Param("page") int page, @Param("size") int size);

    @Query(value = "SELECT group_import.*, product_import.id AS child_id, product_import.group_id AS child_group_id, product_import.createat AS child_createat, product_import.group_import_second_id AS child_group_import_second_id, product_import.product_second_id AS child_product_second_id, product_import.product_unit_second_id AS child_product_unit_second_id, product_import.product_unit_name_category AS child_product_unit_name_category, product_import.price AS child_price, product_import.amount AS child_amount, product_import.note AS child_note, product_import.list_product_serial_id AS child_list_product_serial_id, product_import.type AS child_type, product_import.status AS child_status FROM (SELECT * FROM group_import WHERE group_import.group_id = :group_id AND group_import.status IS DISTINCT FROM :not_status AND group_import.type = :type) AS group_import INNER JOIN (SELECT * FROM product_import WHERE product_import.group_id = :group_id AND product_import.product_second_id = :product_second_id AND product_import.product_unit_second_id = :product_unit_second_id AND product_import.status IS DISTINCT FROM :not_status AND product_import.type = :type ORDER BY createat DESC LIMIT :size OFFSET (:page * :size)) AS product_import ON group_import.group_import_second_id = product_import.group_import_second_id")
    Flux<GroupImportJoinProductImport> getGroupByProductIfNotStatusAndType(@Param("group_id") String groupID, @Param("product_second_id") String product_second_id, @Param("product_unit_second_id") String product_unit_second_id, @Param("not_status") ProductImport.Status not_status, @Param("type") ProductImport.ImportType type, @Param("page") int page, @Param("size") int size);

    @Query(value = "SELECT group_import.*, product_import.id AS child_id, product_import.group_id AS child_group_id, product_import.createat AS child_createat, product_import.group_import_second_id AS child_group_import_second_id, product_import.product_second_id AS child_product_second_id, product_import.product_unit_second_id AS child_product_unit_second_id, product_import.product_unit_name_category AS child_product_unit_name_category, product_import.price AS child_price, product_import.amount AS child_amount, product_import.note AS child_note, product_import.list_product_serial_id AS child_list_product_serial_id, product_import.type AS child_type, product_import.status AS child_status FROM (SELECT * FROM group_import WHERE group_import.group_id = :group_id AND group_import.status IS DISTINCT FROM :not_status) AS group_import INNER JOIN (SELECT * FROM product_import WHERE product_import.group_id = :group_id AND product_import.product_second_id = :product_second_id AND product_import.product_unit_second_id = :product_unit_second_id AND product_import.status IS DISTINCT FROM :not_status ORDER BY createat DESC LIMIT :size OFFSET (:page * :size)) AS product_import ON group_import.group_import_second_id = product_import.group_import_second_id")
    Flux<GroupImportJoinProductImport> getGroupByProductIfNotStatus(@Param("group_id") String groupID, @Param("product_second_id") String product_second_id, @Param("product_unit_second_id") String product_unit_second_id, @Param("not_status") ProductImport.Status not_status, @Param("page") int page, @Param("size") int size);

    @Query(value = "SELECT group_import.*, product_import.id AS child_id, product_import.group_id AS child_group_id, product_import.createat AS child_createat, product_import.group_import_second_id AS child_group_import_second_id, product_import.product_second_id AS child_product_second_id, product_import.product_unit_second_id AS child_product_unit_second_id, product_import.product_unit_name_category AS child_product_unit_name_category, product_import.price AS child_price, product_import.amount AS child_amount, product_import.note AS child_note, product_import.list_product_serial_id AS child_list_product_serial_id, product_import.type AS child_type, product_import.status AS child_status FROM (SELECT * FROM group_import WHERE group_import.group_id = :group_id AND group_import.status IS DISTINCT FROM :not_status AND group_import.type = :type) AS group_import INNER JOIN (SELECT * FROM product_import WHERE product_import.group_id = :group_id AND product_import.product_second_id = :product_second_id AND product_import.product_unit_second_id = :product_unit_second_id AND product_import.status IS DISTINCT FROM :not_status AND product_import.type = :type AND (product_import.createat AT TIME ZONE '+07' BETWEEN :fromtime AND :totime) ORDER BY createat DESC LIMIT :size OFFSET (:page * :size)) AS product_import ON group_import.group_import_second_id = product_import.group_import_second_id")
    Flux<GroupImportJoinProductImport> getGroupByProductIfNotStatusBetweenAndType(@Param("group_id") String groupID, @Param("product_second_id") String product_second_id, @Param("product_unit_second_id") String product_unit_second_id, @Param("fromtime") LocalDateTime from, @Param("totime") LocalDateTime to, @Param("not_status") ProductImport.Status not_status, @Param("type") ProductImport.ImportType type, @Param("page") int page, @Param("size") int size);

    @Query(value = "SELECT group_import.*, product_import.id AS child_id, product_import.group_id AS child_group_id, product_import.createat AS child_createat, product_import.group_import_second_id AS child_group_import_second_id, product_import.product_second_id AS child_product_second_id, product_import.product_unit_second_id AS child_product_unit_second_id, product_import.product_unit_name_category AS child_product_unit_name_category, product_import.price AS child_price, product_import.amount AS child_amount, product_import.note AS child_note, product_import.list_product_serial_id AS child_list_product_serial_id, product_import.type AS child_type, product_import.status AS child_status FROM (SELECT * FROM group_import WHERE group_import.group_id = :group_id AND group_import.status IS DISTINCT FROM :not_status) AS group_import INNER JOIN (SELECT * FROM product_import WHERE product_import.group_id = :group_id AND product_import.product_second_id = :product_second_id AND product_import.product_unit_second_id = :product_unit_second_id AND product_import.status IS DISTINCT FROM :not_status AND (product_import.createat AT TIME ZONE '+07' BETWEEN :fromtime AND :totime) ORDER BY createat DESC LIMIT :size OFFSET (:page * :size)) AS product_import ON group_import.group_import_second_id = product_import.group_import_second_id")
    Flux<GroupImportJoinProductImport> getGroupByProductIfNotStatusBetween(@Param("group_id") String groupID, @Param("product_second_id") String product_second_id, @Param("product_unit_second_id") String product_unit_second_id, @Param("fromtime") LocalDateTime from, @Param("totime") LocalDateTime to, @Param("not_status") ProductImport.Status not_status, @Param("page") int page, @Param("size") int size);

    @Query(value = "SELECT group_import.*, product_import.id AS child_id, product_import.group_id AS child_group_id, product_import.createat AS child_createat, product_import.group_import_second_id AS child_group_import_second_id, product_import.product_second_id AS child_product_second_id, product_import.product_unit_second_id AS child_product_unit_second_id, product_import.product_unit_name_category AS child_product_unit_name_category, product_import.price AS child_price, product_import.amount AS child_amount, product_import.note AS child_note, product_import.list_product_serial_id AS child_list_product_serial_id, product_import.type AS child_type, product_import.status AS child_status FROM (SELECT * FROM group_import WHERE group_import.group_id = :group_id ORDER BY createat DESC LIMIT :size OFFSET (:page * :size)) AS group_import LEFT JOIN (SELECT * FROM product_import WHERE product_import.group_id = :group_id) AS product_import ON group_import.group_import_second_id = product_import.group_import_second_id")
    Flux<GroupImportJoinProductImport> getAll(@Param("group_id") String groupID, @Param("page") int page, @Param("size") int size);

    @Query(value = "SELECT group_import.*, product_import.id AS child_id, product_import.group_id AS child_group_id, product_import.createat AS child_createat, product_import.group_import_second_id AS child_group_import_second_id, product_import.product_second_id AS child_product_second_id, product_import.product_unit_second_id AS child_product_unit_second_id, product_import.product_unit_name_category AS child_product_unit_name_category, product_import.price AS child_price, product_import.amount AS child_amount, product_import.note AS child_note, product_import.list_product_serial_id AS child_list_product_serial_id, product_import.type AS child_type, product_import.status AS child_status FROM (SELECT * FROM group_import WHERE group_import.group_id = :group_id AND group_import.group_import_second_id = :group_import_second_id) AS group_import LEFT JOIN (SELECT * FROM product_import WHERE product_import.group_id = :group_id AND product_import.group_import_second_id = :group_import_second_id) AS product_import ON group_import.group_import_second_id = product_import.group_import_second_id")
    Flux<GroupImportJoinProductImport> getByGroupID(@Param("group_id") String groupID, @Param("group_import_second_id") String groupImportSecondID);

    @Query(value = "SELECT group_import.*, product_import.id AS child_id, product_import.group_id AS child_group_id, product_import.createat AS child_createat, product_import.group_import_second_id AS child_group_import_second_id, product_import.product_second_id AS child_product_second_id, product_import.product_unit_second_id AS child_product_unit_second_id, product_import.product_unit_name_category AS child_product_unit_name_category, product_import.price AS child_price, product_import.amount AS child_amount, product_import.note AS child_note, product_import.list_product_serial_id AS child_list_product_serial_id, product_import.type AS child_type, product_import.status AS child_status FROM (SELECT * FROM group_import WHERE group_import.group_id = :group_id AND status = 'DONE' AND group_import.type = :type AND supplier_id = :supplier_id AND total_price * (1-discount_percent/100) - discount_amount + additional_fee > payment) AS group_import LEFT JOIN (SELECT * FROM product_import WHERE product_import.group_id = :group_id) AS product_import ON group_import.group_import_second_id = product_import.group_import_second_id")
    Flux<GroupImportJoinProductImport> getDebtOfType(@Param("group_id") String groupID, @Param("type") ProductImport.ImportType importType, @Param("supplier_id") String supplierID);

    @Query(value = "SELECT group_import.*, product_import.id AS child_id, product_import.group_id AS child_group_id, product_import.createat AS child_createat, product_import.group_import_second_id AS child_group_import_second_id, product_import.product_second_id AS child_product_second_id, product_import.product_unit_second_id AS child_product_unit_second_id, product_import.product_unit_name_category AS child_product_unit_name_category, product_import.price AS child_price, product_import.amount AS child_amount, product_import.note AS child_note, product_import.list_product_serial_id AS child_list_product_serial_id, product_import.type AS child_type, product_import.status AS child_status FROM (SELECT * FROM group_import WHERE group_import.group_id = :group_id AND status = 'DONE' AND supplier_id = :supplier_id AND total_price * (1-discount_percent/100) - discount_amount + additional_fee > payment) AS group_import LEFT JOIN (SELECT * FROM product_import WHERE product_import.group_id = :group_id) AS product_import ON group_import.group_import_second_id = product_import.group_import_second_id")
    Flux<GroupImportJoinProductImport> getDebt(@Param("group_id") String groupID, @Param("supplier_id") String supplierID);

    @Query(value = """
            SELECT group_import.*,
                   product_import.id AS child_id,
                   product_import.group_id AS child_group_id,
                   product_import.createat AS child_createat,
                   product_import.group_import_second_id AS child_group_import_second_id,
                   product_import.product_second_id AS child_product_second_id,
                   product_import.product_unit_second_id AS child_product_unit_second_id,
                   product_import.product_unit_name_category AS child_product_unit_name_category,
                   product_import.price AS child_price,
                   product_import.amount AS child_amount,
                   product_import.note AS child_note,
                   product_import.list_product_serial_id AS child_list_product_serial_id,
                   product_import.type AS child_type,
                   product_import.status AS child_status
            FROM
              (SELECT *
               FROM group_import
               WHERE group_import.group_id = :group_id
                 AND group_import.type = :type
                 AND meta_search LIKE :search_txt) AS group_import
            LEFT JOIN
              (SELECT *
               FROM product_import
               WHERE product_import.group_id = :group_id) AS product_import ON group_import.group_import_second_id = product_import.group_import_second_id
            """)
    Flux<GroupImportJoinProductImport> searchByType(@Param("group_id") String groupID, @Param("type") ProductImport.ImportType importType, @Param("search_txt") String searchTxt);

    @Query(value = """
            SELECT group_import.*,
                   product_import.id AS child_id,
                   product_import.group_id AS child_group_id,
                   product_import.createat AS child_createat,
                   product_import.group_import_second_id AS child_group_import_second_id,
                   product_import.product_second_id AS child_product_second_id,
                   product_import.product_unit_second_id AS child_product_unit_second_id,
                   product_import.product_unit_name_category AS child_product_unit_name_category,
                   product_import.price AS child_price,
                   product_import.amount AS child_amount,
                   product_import.note AS child_note,
                   product_import.list_product_serial_id AS child_list_product_serial_id,
                   product_import.type AS child_type,
                   product_import.status AS child_status
            FROM
              (SELECT *
               FROM group_import
               WHERE group_import.group_id = :group_id
                 AND meta_search LIKE :search_txt) AS group_import
            LEFT JOIN
              (SELECT *
               FROM product_import
               WHERE product_import.group_id = :group_id) AS product_import ON group_import.group_import_second_id = product_import.group_import_second_id
            """)
    Flux<GroupImportJoinProductImport> search(@Param("group_id") String groupID, @Param("search_txt") String searchTxt);

}
